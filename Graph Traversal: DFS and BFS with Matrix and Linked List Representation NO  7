#include<iostream> 
#include<stack> 
#include<queue> 
using namespace std; 
struct node 
{ 
 public: 
 node *next; 
 int data; 
}; 
class matrix 
{ 
 public: 
 int n,i,j,p,t,c,c1,count; 
 int M[30][30]; 
 int city[10]; 
 int visited[10],visited1[10]; 
 node *list[10],*nnode,*temp; 
 int n1,m; 
 void create() 
 { 
 cout<<"\n enter the no.of vertices"; 
 cin>>n1; 
 for(int i=0;i<n1;i++) 
 { 
  cout<<"\n enter the name of vertex:- "; 
  list[i]=new node; 
  cin>>list[i]->data; 
  list[i]->next=NULL; 
  cout<<"\n enter the no.of vertices connected to "<<list[i]->data<<":- "; 
  cin>>m; 
  temp=list[i]; 
  for(int j=0;j<m;j++) 
  { 
   nnode=new node; 
   cout<<"\n enter the name of vertex connected to "<<list[i]->data<<":- "; 
   cin>>nnode->data; 
   nnode->next=NULL; 
   temp->next=nnode; 
      temp=nnode; 
  } 
 } 
 for(int i=0;i<n1;i++) 
 { 
  temp=list[i]; 
  cout<<temp->data<<"->"; 
  temp=temp->next; 
  while(temp!=NULL) 
  { 
   cout<<temp->data<<" "; 
   temp=temp->next; 
  } 
  cout<<endl; 
 } 
} 
  
 void read() 
 { 
    cout<<"\n enter the no.of vertex :-"; 
       cin>>n; 
    for(i=1;i<=n;i++) 
    { 
     for(j=1;j<=n;j++) 
    { 
       M[i][j]=0; 
    } 
    } 
    cout<<"\n enter how many path exits:- "; 
    cin>>p; 
    for(i=1;i<=p;i++) 
    { 
        cout<<"\n enter the source city:-"; 
        cin>>c; 
        cout<<"\n enter the destination city:-"; 
        cin>>c1;                                                                    
        M[c][c1]=M[c1][c]=1; 
    } 
   } 
   void display() 
   { 
      for(i=1;i<=n;i++) 
    { 
     for(j=1;j<=n;j++) 
    { 
       cout<<M[i][j]<<" "; 
    } 
    cout<<endl; 
    } 
   } 
   void DFS() 
   { 
      stack<int>s1; 
      int v1,v2,v3; 
      int flag,count=0; 
      cout<<"\n enter the starting vertex="; 
      cin>>v1; 
      s1.push(v1); 
      visited[v1]=1; 
      cout<<v1<<" "; 
      while(!s1.empty()) 
      { 
       v2=s1.top(); 
       count++; 
       flag=0; 
        for(v3=1;v3<=n;v3++) 
        { 
          if(v1!=v3 && M[v2][v3]!=0  && visited[v3]==0) 
          { 
          s1.push(v3); 
          visited[v3]=1; 
          cout<<v3<<" "; 
          flag=1; 
          break; 
     } 
    } 
    if(flag==0) 
    { 
       s1.pop(); 
    } 
    if(count==n) 
    break; 
     } 
   } 
   void BFS() 
   { 
      queue<int>q; 
      int v,s; 
      cout<<"\n enter the starting vertex="; 
      cin>>v; 
      q.push(v); 
      visited1[v]=1; 
      while(!q.empty()) 
      { 
       s=q.front(); 
       cout<<s<<" "; 
       q.pop(); 
       for(int i=0;i<n1;i++) 
        { 
            if(list[i]->data==s) 
            { 
                temp=list[i]->next;   
                break; 
            } 
        } 
          while(temp!=NULL) 
          { 
           if(visited1[temp->data]==0) 
           { 
         q.push(temp->data); 
         visited1[temp->data]=1; 
      } 
      temp=temp->next; 
     } 
     } 
   } 
    
}; 
int main() 
{ 
 matrix m; 
 m.read(); 
 m.display(); 
 for(int i=1; i<=10; i++)  
 { 
       m.visited[i] = 0; 
    } 
    for(int i=0;i<10;i++) 
    { 
     m.visited1[i]=0; 
 } 
    m.count = 1;  
    cout<<"\n DFS traversal:-"; 
    m.DFS(); 
    m.create(); 
    cout<<"\n BFS traversal:-"; 
    m.BFS(); 
 return 0; 
} 
OUTPUT: 
enter the no.of vertex :-4 
 enter how many path exits:- 3 
 enter the source city:-1 
 enter the destination city:-2 
 enter the source city:-2 
 enter the destination city:-3 
 enter the source city:-3 
enter the destination city:-4 
0 1 0 0 
1 0 1 0 
0 1 0 1 
0 0 1 0 
DFS traversal:- 
enter the starting vertex=1 
1 2 3 4 
enter the no.of vertices 3 
enter the name of vertex:- 1 
enter the no.of vertices connected to 1:- 2 
enter the name of vertex connected to 1:- 2 
enter the name of vertex connected to 1:- 3 
enter the name of vertex:- 2 
enter the no.of vertices connected to 2:- 2 
enter the name of vertex connected to 2:- 1 
enter the name of vertex connected to 2:- 3 
enter the name of vertex:- 3 
enter the no.of vertices connected to 3:- 2 
enter the name of vertex connected to 3:- 1 
enter the name of vertex connected to 3:- 2 
1->2 3 
2->1 3 
3->1 2 
BFS traversal:- 
enter the starting vertex=1 
1 2 3 
EXPLNATION : 
This program demonstrates graph traversal using two common techniques: Depth First Search (DFS) and Breadth First Search (BFS). It uses both adjacency matrix and linked list to represent a graph, offering two ways of storing graph connections.
Graph Representation:
The graph can be represented using:
An adjacency matrix (M[30][30]), where M[i][j] is 1 if there is an edge between vertex i and vertex j, and 0 otherwise.
A linked list where each node contains a vertex and points to the next node, representing a connected vertex.
DFS (Depth First Search):
The DFS algorithm uses a stack to explore the graph. Starting from a given vertex, it explores as far as possible along each branch before backtracking. It visits all connected vertices recursively, marking them as visited.
Steps:
Push the starting vertex onto the stack.
Visit each unvisited neighboring vertex, pushing it onto the stack.
Pop from the stack and backtrack if there are no unvisited neighbors.
Repeat until all vertices are visited or the stack is empty.
BFS (Breadth First Search):
The BFS algorithm uses a queue to explore the graph level by level. It visits all neighbors of a node before moving on to the next level of neighbors.
Steps:
Enqueue the starting vertex.
Dequeue a vertex, visit it, and enqueue all of its unvisited neighbors.
Repeat until the queue is empty.
Program Flow:
The program first allows the user to input the number of vertices and the connections between them.
It then allows the user to perform DFS and BFS from a given starting vertex, displaying the traversal sequence.
By combining the matrix and linked list approaches, the program shows different ways of representing and traversing a graph, offering flexibility in how graph data is handled.







